using Prism.Reflection;
using Prism.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Prism.Export
{
	public abstract class ReflectorBase
	{
		/// <summary>
		/// Header text which should be attached to every export file
		/// </summary>
		private static string s_ExportHeader = @"/////////////////////////////////////////////////////////////////////////////////////////////
/// This file contains auto-generated content as exported by the Prism++ content pipeline ///
///                                                                                       ///
/// DO NOT EDIT THIS FILE                                                                 ///
///  Edit the original file and then re-run PrismTool to update this file                 ///
/////////////////////////////////////////////////////////////////////////////////////////////
";
		/// <summary>
		/// The extension which will be applied to export files
		/// </summary>
		[CmdArg(Arg = "export-ext", Usage = "The extention all exported files will prepend to thier current", MustExist = false)]
		private string m_ExportExtension = ".refl";

		/// <summary>
		/// File information about a 
		/// </summary>
		public class ExportFile
		{
			/// <summary>
			/// The full path to this file
			/// </summary>
			public string Path;

			/// <summary>
			/// Is this file an include file
			/// </summary>
			public bool IsInclude;

			/// <summary>
			/// Is this file newly made
			/// </summary>
			public bool IsNewFile;
		}
				
		/// <summary>
		/// Runs through each file, as specified by the reflector
		/// </summary>
		/// <returns>The new reflection files which have been generated</returns>
		public abstract List<ExportFile> Run();

		/// <summary>
		/// Reflect a given input file and return the export information about any new files
		/// </summary>
		/// <returns>All the reflection files which have been created from these</returns>
		protected List<ExportFile> ReflectFile(ReflectionSettings settings, string sourcePath, string exportDirectory)
		{
			string includeContent = "";
			string sourceContent = "";
			
			includeContent = @"%FILE_EXPORT_HEADER%
#pragma once
#include <Prism.h>

#ifndef PRISM_DEFER
#define PRISM_DEFER(...) __VA_ARGS__
#endif

#ifdef %CLASS_TOKEN%
#undef %CLASS_TOKEN%
#endif
#define %CLASS_TOKEN%(...) PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef %STRUCT_TOKEN%
#undef %STRUCT_TOKEN%
#endif
#define %STRUCT_TOKEN%(...) PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef %ENUM_TOKEN%
#undef %ENUM_TOKEN%
#endif
#define %ENUM_TOKEN%(...) PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef %FUNCTION_TOKEN%
#undef %FUNCTION_TOKEN%
#endif
#define %FUNCTION_TOKEN%(...)

#ifdef %VARIABLE_TOKEN%
#undef %VARIABLE_TOKEN%
#endif
#define %VARIABLE_TOKEN%(...)
";
			// Setup defaults
			sourceContent = @"%FILE_EXPORT_HEADER%
#include ""%FILE_PATH%""
";

			// Resolve placeholders
			includeContent = includeContent
				.Replace("%FILE_EXPORT_HEADER%", s_ExportHeader)
				.Replace("%CLASS_TOKEN%", settings.ClassToken)
				.Replace("%STRUCT_TOKEN%", settings.StructToken)
				.Replace("%ENUM_TOKEN%", settings.EnumToken)
				.Replace("%FUNCTION_TOKEN%", settings.FunctionToken)
				.Replace("%VARIABLE_TOKEN%", settings.VariableToken);

			sourceContent = sourceContent
				.Replace("%FILE_EXPORT_HEADER%", s_ExportHeader)
				.Replace("%FILE_PATH%", sourcePath);

			// Reflect the file
			using (FileStream stream = new FileStream(sourcePath, FileMode.Open))
			{
				HeaderReflection file = HeaderReflection.Generate(settings, stream);
				List<ExportFile> exports = new List<ExportFile>();

				// Export tokens, if any have been found
				if (file.ReflectedTokenCount != 0)
				{
					// Generate the reflection export data for all tokens found
					for (int i = 0; i < file.ReflectedTokenCount; ++i)
					{
						var token = file.ReflectedTokens[i];

						string tokenHeader = token.GenerateHeaderReflectionContent();
						string tokenInclude = token.GenerateIncludeReflectionContent();
						string tokenSource = token.GenerateSourceReflectionContent();

						// Raw include content
						string finalInclude = "";
						string finalSource = tokenSource;

						finalInclude += tokenInclude + "\n";

						// Macro replacement 
						string headerMacro = @"
#if %TOKEN_CONDITION%
#ifdef PRISM_REFLECTION_BODY_%TOKEN_LINE%
#undef PRISM_REFLECTION_BODY_%TOKEN_LINE%
#endif
#define PRISM_REFLECTION_BODY_%TOKEN_LINE% %MACRO_CONTENT%
#endif
";
						finalInclude += headerMacro
							.Replace("%TOKEN_CONDITION%", "" + token.PreProcessorCondition)
							.Replace("%TOKEN_LINE%", "" + token.TokenLineNumber)
							.Replace("%MACRO_CONTENT%", tokenHeader.Replace("\r\n", " \\\n"));


						// Add line breaks to make debugging easier on the eyes
						includeContent += "\n//=========== TOKEN " + token.TokenLineNumber + " START ===========//\n" + finalInclude + "\n//=========== TOKEN " + token.TokenLineNumber + " END ===========//\n";
						sourceContent += "\n//=========== TOKEN " + token.TokenLineNumber + " START ===========//\n" + finalSource + "\n//=========== TOKEN " + token.TokenLineNumber + " END ===========//\n";
					}


					// Fix line-endings
					includeContent = includeContent.Replace("\r\n", "\n").Replace("\n", "\r\n");
					sourceContent = sourceContent.Replace("\r\n", "\n").Replace("\n", "\r\n");

					
					// Export header
					{
						ExportFile includeExport = new ExportFile();
						string includeExportPath = Path.Combine(exportDirectory, Path.GetFileNameWithoutExtension(sourcePath) + m_ExportExtension + Path.GetExtension(sourcePath));
						string includeExportDir = Path.GetDirectoryName(includeExportPath);

						if (!Directory.Exists(includeExportDir))
							Directory.CreateDirectory(includeExportDir);

						includeExport.IsInclude = true;
						includeExport.IsNewFile = !File.Exists(includeExportPath);
						includeExport.Path = includeExportPath;

						File.WriteAllText(includeExportPath, includeContent);
						exports.Add(includeExport);
					}

					// Export source
					{
						ExportFile sourceExport = new ExportFile();
						string sourceExportPath = Path.Combine(exportDirectory, Path.GetFileNameWithoutExtension(sourcePath) + m_ExportExtension + ".cpp");
						string sourceExportDir = Path.GetDirectoryName(sourceExportPath);

						if (!Directory.Exists(sourceExportDir))
							Directory.CreateDirectory(sourceExportDir);

						sourceExport.IsInclude = false;
						sourceExport.IsNewFile = !File.Exists(sourceExportPath);
						sourceExport.Path = sourceExportPath;

						File.WriteAllText(sourceExportPath, sourceContent);
						exports.Add(sourceExport);
					}
				}

				return exports;
			}
		}
	}
}
