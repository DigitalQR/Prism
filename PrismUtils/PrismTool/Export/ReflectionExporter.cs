using Prism.Parsing;
using Prism.Reflection.Tokens;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Prism.Export
{
	public enum ReflectionExportState
	{
		SucT,
		NoWrite,
	}

	public class ReflectionExporter
	{
		/// <summary>
		/// Header text which should be attached to every exported file
		/// </summary>
		private static string s_ExportHeader = @"///////////////////////////////////////////////////////////////////////////////////////////
/// This file contains auto-generated content as exported by the Prism content pipeline ///
///                                                                                     ///
/// DO NOT EDIT THIS FILE                                                               ///
///  Edit the original file and then re-run PrismTool to update this file               ///
///////////////////////////////////////////////////////////////////////////////////////////
";

		private FileInfo m_SourceFile;
		private ParsedHeader m_ParsedHeader;
		private ReflectionSettings m_Settings;

		public ReflectionExporter(FileInfo sourceFile, ParsedHeader header, ReflectionSettings settings)
		{
			m_SourceFile = sourceFile;
			m_ParsedHeader = header;
			m_Settings = settings;
		}

		/// <summary>
		/// Gernerate all the content for the include
		/// </summary>
		public StringBuilder GenerateIncludeContent()
		{
			StringBuilder builder = new StringBuilder(s_ExportHeader);
			builder.Append(@"#pragma once
#include <Prism.h>

#ifndef NO_REFL_$(UniqueSourceName)
#define REFL_$(UniqueSourcePath)

///
/// DEFINE SUPPORTED TOKENS
///

#ifdef PRISM_DEFER
#undef PRISM_DEFER
#endif
#define PRISM_DEFER(...) __VA_ARGS__

#ifdef $(ClassReflectionToken)
#undef $(ClassReflectionToken)
#endif
#define $(ClassReflectionToken)(...) PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef $(StructReflectionToken)
#undef $(StructReflectionToken)
#endif
#define $(StructReflectionToken)(...) PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef $(EnumReflectionToken)
#undef $(EnumReflectionToken)
#endif
#define $(EnumReflectionToken)(...) //PRISM_DEFER(PRISM_REFLECTION_BODY_) ## __LINE__

#ifdef $(FunctionReflectionToken)
#undef $(FunctionReflectionToken)
#endif
#define $(FunctionReflectionToken)(...)

#ifdef $(VariableReflectionToken)
#undef $(VariableReflectionToken)
#endif
#define $(VariableReflectionToken)(...)

///////////////////////////////////////
");

			foreach (IReflectableToken token in m_ParsedHeader.ParsedTokens)
			{
				builder.Append(token.GenerateIncludeContent(null));
				builder.Append(@"
///////////////////////////////////////
");
			}

			builder.Append("\n#endif\n");
			return ExpandMacros(builder);
		}

		/// <summary>
		/// Gernerate all the content for the source
		/// </summary>
		public StringBuilder GenerateSourceContent()
		{
			StringBuilder builder = new StringBuilder(s_ExportHeader);
			builder.Append(@"#include ""$(SourceFilePath)""
#ifdef REFL_$(UniqueSourcePath)
");

			foreach (IReflectableToken token in m_ParsedHeader.ParsedTokens)
			{
				builder.Append(token.GenerateImplementationContent(null));
				builder.Append(@"
///////////////////////////////////////
");
			}

			builder.Append("\n#endif\n");
			return ExpandMacros(builder);
		}

		/// <summary>
		/// Convert a path into a code-safe token
		/// </summary>
		private static string MakePathSafe(string path)
		{
			return path.Replace(' ', '_')
					.Replace('-', '_')
					.Replace('.', '_')
					.Replace(':', '_')
					.Replace('\\', '_')
					.Replace('/', '_');
		}

		/// <summary>
		/// Expand any macros relating to this type (Missing macros will be left)
		/// $(SourceFileName)
		/// $(SourceFilePath)
		/// $(UniqueSourceName)
		/// $(UniqueSourcePath)
		/// $(ClassReflectionToken)
		/// $(StructReflectionToken)
		/// $(EnumReflectionToken)
		/// $(VariableReflectionToken)
		/// </summary>
		/// <param name="input">The raw input string which should have it's macros replaced</param>
		/// <param name="prefix">The prefix to apply to every macro</param>
		/// <param name="suffix">The suffix to apply to each macro</param>
		/// <returns>The string with all relevent macros expanded</returns>
		public StringBuilder ExpandMacros(StringBuilder builder, string prefix = "", string suffix = "")
		{
			builder.Replace("$(" + prefix + "SourceFileName" + suffix + ")", m_SourceFile.Name);
			builder.Replace("$(" + prefix + "SourceFilePath" + suffix + ")", m_SourceFile.FullName);
			builder.Replace("$(" + prefix + "UniqueSourceName" + suffix + ")", MakePathSafe(m_SourceFile.Name.ToUpper()));
			builder.Replace("$(" + prefix + "UniqueSourcePath" + suffix + ")", MakePathSafe(m_SourceFile.FullName.ToUpper()));

			builder.Replace("$(" + prefix + "ClassReflectionToken" + suffix + ")", m_Settings.ClassToken);
			builder.Replace("$(" + prefix + "StructReflectionToken" + suffix + ")", m_Settings.StructToken);
			builder.Replace("$(" + prefix + "EnumReflectionToken" + suffix + ")", m_Settings.EnumToken);
			builder.Replace("$(" + prefix + "FunctionReflectionToken" + suffix + ")", m_Settings.FunctionToken);
			builder.Replace("$(" + prefix + "VariableReflectionToken" + suffix + ")", m_Settings.VariableToken);
			return builder;
		}
	}
}
